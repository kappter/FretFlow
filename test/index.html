<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Music Theory Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/midi-parser-js@4.0.4/src/main.js"></script>
    <style>
        :root {
            --theme-color: #00ffcc;
            --theme-color-rgb: 0, 255, 204;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a1a, #2c2c2c);
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
            background: #2a2a2a;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(var(--theme-color-rgb), 0.2);
            transition: transform 0.3s ease;
        }
        
        .container:hover {
            transform: translateY(-5px);
        }
        
        h1 {
            text-align: center;
            color: var(--theme-color);
            text-shadow: 0 0 10px rgba(var(--theme-color-rgb), 0.5);
            margin-bottom: 20px;
            font-size: 28px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        select, input[type="color"], button, input[type="file"] {
            padding: 10px 15px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            background: #3a3a3a;
            color: #e0e0e0;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            font-family: inherit;
        }
        
        select:hover, button:hover {
            background: #4a4a4a;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        input[type="color"] {
            width: 50px;
            height: 40px;
            padding: 5px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .playback-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            background: #333;
            padding: 15px;
            border-radius: 8px;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: #4a4a4a;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--theme-color);
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--theme-color);
            cursor: pointer;
            border: none;
        }
        
        .midi-info {
            background: #333;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .midi-info::-webkit-scrollbar {
            width: 8px;
        }
        
        .midi-info::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }
        
        .midi-info::-webkit-scrollbar-thumb {
            background: var(--theme-color);
            border-radius: 4px;
        }
        
        .canvas-container {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .canvas-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-label {
            font-size: 16px;
            color: var(--theme-color);
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        canvas {
            background: #333;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(var(--theme-color-rgb), 0.1);
            max-width: 100%;
            height: auto;
        }
        
        .status-message {
            text-align: center;
            padding: 15px;
            background: #333;
            border-radius: 5px;
            margin-bottom: 20px;
            color: var(--theme-color);
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            select, button {
                width: 100%;
            }
            
            .playback-controls {
                flex-direction: column;
            }
            
            .speed-control {
                width: 100%;
                justify-content: space-between;
            }
            
            input[type="range"] {
                flex: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MIDI Music Theory Visualizer</h1>
        
        <div class="controls">
            <button id="uploadBtn">üìÅ Upload MIDI</button>
            <input type="file" id="fileInput" accept=".mid,.midi">
            <select id="sampleSelect">
                <option value="">Select Sample MIDI</option>
                <option value="cmajor">C Major Scale</option>
                <option value="blues">Blues Riff</option>
                <option value="arpeggio">Arpeggio Pattern</option>
            </select>
            <select id="notationSelect">
                <option value="sharp">Sharps</option>
                <option value="flat">Flats</option>
            </select>
            <select id="tuningSelect">
                <option value="standard">Standard Tuning</option>
                <option value="dropd">Drop D Tuning</option>
                <option value="openg">Open G Tuning</option>
                <option value="dadgad">DADGAD Tuning</option>
            </select>
            <select id="stringOrderSelect">
                <option value="highBottom">High String Bottom</option>
                <option value="lowBottom">Low String Bottom</option>
            </select>
            <input type="color" id="themeColor" value="#00ffcc" title="Theme Color">
        </div>
        
        <div class="playback-controls">
            <button id="playBtn" disabled>‚ñ∂ Play</button>
            <button id="pauseBtn" disabled>‚è∏ Pause</button>
            <button id="stopBtn" disabled>‚èπ Stop</button>
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="0.5" max="2" step="0.1" value="1" disabled>
                <span id="speedDisplay">1.0x</span>
            </div>
        </div>
        
        <div class="status-message" id="statusMessage">
            Upload a MIDI file or select a sample to begin
        </div>
        
        <div class="midi-info" id="midiInfo"></div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <div class="canvas-label">Guitar Fretboard</div>
                <canvas id="fretboardCanvas" width="840" height="180"></canvas>
            </div>
            <div class="canvas-wrapper">
                <div class="canvas-label">Piano Roll</div>
                <canvas id="pianoCanvas" width="840" height="120"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const tunings = {
            standard: [40, 45, 50, 55, 59, 64], // E2 A2 D3 G3 B3 E4
            dropd: [38, 45, 50, 55, 59, 64],    // D2 A2 D3 G3 B3 E4
            openg: [38, 43, 50, 55, 59, 62],    // D2 G2 D3 G3 B3 D4
            dadgad: [38, 45, 50, 55, 57, 62]    // D2 A2 D3 G3 A3 D4
        };
        
        const sharpNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const flatNotes = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
        
        // State
        let midiNotes = [];
        let playbackTimer = null;
        let playbackTime = 0;
        let isPlaying = false;
        let currentTuning = tunings.standard;
        let currentNotation = 'sharp';
        let currentStringOrder = 'highBottom';
        let themeColor = '#00ffcc';
        let activeNotes = new Set();
        
        // DOM Elements
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const sampleSelect = document.getElementById('sampleSelect');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const midiInfo = document.getElementById('midiInfo');
        const statusMessage = document.getElementById('statusMessage');
        const fretboardCanvas = document.getElementById('fretboardCanvas');
        const pianoCanvas = document.getElementById('pianoCanvas');
        const notationSelect = document.getElementById('notationSelect');
        const tuningSelect = document.getElementById('tuningSelect');
        const stringOrderSelect = document.getElementById('stringOrderSelect');
        const themeColorInput = document.getElementById('themeColor');
        
        // Utility Functions
        function noteToName(noteNumber, notation = 'sharp') {
            const noteNames = notation === 'sharp' ? sharpNotes : flatNotes;
            const octave = Math.floor(noteNumber / 12) - 1;
            const note = noteNames[noteNumber % 12];
            return `${note}${octave}`;
        }
        
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }
        
        function updateThemeColor(color) {
            themeColor = color;
            const rgb = hexToRgb(color);
            document.documentElement.style.setProperty('--theme-color', color);
            document.documentElement.style.setProperty('--theme-color-rgb', rgb);
            drawFretboard();
            drawPianoRoll();
        }
        
        // MIDI Parsing
        function parseMidi(data) {
            try {
                const midi = MidiParser.parse(data);
                const notes = [];
                let tempo = 500000; // Default tempo (microseconds per quarter note)
                
                midi.track.forEach(track => {
                    let currentTime = 0;
                    track.event.forEach(event => {
                        currentTime += event.deltaTime;
                        
                        // Check for tempo changes
                        if (event.type === 255 && event.metaType === 81) {
                            tempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                        }
                        
                        // Note On events
                        if (event.type === 9 && event.data && event.data[1] > 0) {
                            const noteNumber = event.data[0];
                            const timeInSeconds = (currentTime / midi.timeDivision) * (tempo / 1000000);
                            notes.push({
                                name: noteToName(noteNumber, currentNotation),
                                number: noteNumber,
                                time: timeInSeconds
                            });
                        }
                    });
                });
                
                return notes.sort((a, b) => a.time - b.time);
            } catch (error) {
                console.error('MIDI parsing error:', error);
                return [];
            }
        }
        
        // Sample MIDI Data
        function generateSampleMidi(type) {
            const samples = {
                cmajor: [
                    { number: 60, time: 0 },    // C4
                    { number: 62, time: 0.5 },  // D4
                    { number: 64, time: 1.0 },  // E4
                    { number: 65, time: 1.5 },  // F4
                    { number: 67, time: 2.0 },  // G4
                    { number: 69, time: 2.5 },  // A4
                    { number: 71, time: 3.0 },  // B4
                    { number: 72, time: 3.5 }   // C5
                ],
                blues: [
                    { number: 60, time: 0 },    // C4
                    { number: 63, time: 0.5 },  // Eb4
                    { number: 65, time: 1.0 },  // F4
                    { number: 66, time: 1.5 },  // F#4
                    { number: 67, time: 2.0 },  // G4
                    { number: 70, time: 2.5 },  // Bb4
                    { number: 60, time: 3.0 }   // C4
                ],
                arpeggio: [
                    { number: 60, time: 0 },    // C4
                    { number: 64, time: 0.3 },  // E4
                    { number: 67, time: 0.6 },  // G4
                    { number: 72, time: 0.9 },  // C5
                    { number: 67, time: 1.2 },  // G4
                    { number: 64, time: 1.5 },  // E4
                    { number: 60, time: 1.8 }   // C4
                ]
            };
            
            return samples[type].map(note => ({
                ...note,
                name: noteToName(note.number, currentNotation)
            }));
        }
        
        // Drawing Functions
        function drawFretboard() {
            const ctx = fretboardCanvas.getContext('2d');
            ctx.clearRect(0, 0, fretboardCanvas.width, fretboardCanvas.height);
            
            const numStrings = 6;
            const numFrets = 12;
            const stringSpacing = 25;
            const fretSpacing = 60;
            const startX = 60;
            const startY = 20;
            
            const stringOrder = currentStringOrder === 'lowBottom' 
                ? [...currentTuning].reverse() 
                : currentTuning;
            
            // Draw strings
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            for (let i = 0; i < numStrings; i++) {
                const y = startY + i * stringSpacing;
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(startX + numFrets * fretSpacing, y);
                ctx.stroke();
            }
            
            // Draw frets
            ctx.strokeStyle = '#888';
            for (let f = 0; f <= numFrets; f++) {
                const x = startX + f * fretSpacing;
                ctx.lineWidth = f === 0 ? 3 : 1;
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, startY + (numStrings - 1) * stringSpacing);
                ctx.stroke();
            }
            
            // Draw fret markers
            const markers = [3, 5, 7, 9, 12];
            ctx.fillStyle = '#555';
            markers.forEach(fret => {
                const x = startX + (fret - 0.5) * fretSpacing;
                const y = startY + ((numStrings - 1) * stringSpacing) / 2;
                if (fret === 12) {
                    ctx.beginPath();
                    ctx.arc(x, y - 15, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x, y + 15, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw fret numbers
            ctx.fillStyle = themeColor;
            ctx.font = '11px Roboto';
            ctx.textAlign = 'center';
            for (let f = 0; f <= numFrets; f++) {
                const x = startX + f * fretSpacing;
                ctx.fillText(f.toString(), x, startY + numStrings * stringSpacing + 10);
            }
            
            // Draw string labels
            ctx.font = 'bold 12px Roboto';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            stringOrder.forEach((noteNum, i) => {
                const y = startY + i * stringSpacing;
                const noteName = noteToName(noteNum, currentNotation);
                ctx.fillText(noteName, startX - 10, y);
            });
            
            // Draw active notes
            ctx.fillStyle = themeColor;
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            activeNotes.forEach(noteNumber => {
                stringOrder.forEach((stringNote, stringIndex) => {
                    for (let fret = 0; fret <= numFrets; fret++) {
                        if (stringNote + fret === noteNumber) {
                            const x = startX + fret * fretSpacing;
                            const y = startY + stringIndex * stringSpacing;
                            ctx.beginPath();
                            ctx.arc(x, y, 10, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            
                            // Draw note name
                            ctx.fillStyle = '#1a1a1a';
                            ctx.font = 'bold 10px Roboto';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const noteName = noteToName(noteNumber, currentNotation).replace(/\d/, '');
                            ctx.fillText(noteName, x, y);
                            ctx.fillStyle = themeColor;
                        }
                    }
                });
            });
        }
        
        function drawPianoRoll() {
            const ctx = pianoCanvas.getContext('2d');
            ctx.clearRect(0, 0, pianoCanvas.width, pianoCanvas.height);
            
            const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const blackKeyOffsets = [0, 1, 3, 4, 5]; // Positions where black keys exist
            const numWhiteKeys = 14; // 2 octaves
            const keyWidth = pianoCanvas.width / numWhiteKeys;
            const blackKeyHeight = pianoCanvas.height * 0.6;
            const startingOctave = 3;
            
            const themeColorRgb = hexToRgb(themeColor);
            
            // Draw white keys
            for (let i = 0; i < numWhiteKeys; i++) {
                const x = i * keyWidth;
                const note = whiteKeys[i % 7];
                const octave = startingOctave + Math.floor(i / 7);
                const noteNumber = (octave + 1) * 12 + [0, 2, 4, 5, 7, 9, 11][i % 7];
                
                // Gradient fill
                const grad = ctx.createLinearGradient(x, 0, x, pianoCanvas.height);
                grad.addColorStop(0, '#fafafa');
                grad.addColorStop(1, '#dcdcdc');
                ctx.fillStyle = grad;
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.fillRect(x, 0, keyWidth, pianoCanvas.height);
                ctx.strokeRect(x, 0, keyWidth, pianoCanvas.height);
                
                // Highlight if active
                if (activeNotes.has(noteNumber)) {
                    ctx.fillStyle = `rgba(${themeColorRgb}, 0.4)`;
                    ctx.fillRect(x, 0, keyWidth, pianoCanvas.height);
                }
                
                // Label
                ctx.font = activeNotes.has(noteNumber) ? 'bold 11px Roboto' : '10px Roboto';
                ctx.fillStyle = activeNotes.has(noteNumber) ? themeColor : '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(`${note}${octave}`, x + keyWidth / 2, pianoCanvas.height - 5);
            }
            
            // Draw black keys
            for (let i = 0; i < numWhiteKeys; i++) {
                const note = whiteKeys[i % 7];
                const octave = startingOctave + Math.floor(i / 7);
                
                if (blackKeyOffsets.includes(i % 7)) {
                    const x = (i + 1) * keyWidth - keyWidth / 4;
                    const semitone = ([0, 2, 4, 5, 7, 9, 11][i % 7] + 1) % 12;
                    const noteNumber = (octave + 1) * 12 + semitone;
                    
                    // Gradient fill
                    const grad = ctx.createLinearGradient(x - keyWidth / 4, 0, x - keyWidth / 4, blackKeyHeight);
                    grad.addColorStop(0, '#333');
                    grad.addColorStop(1, '#000');
                    ctx.fillStyle = grad;
                    ctx.strokeStyle = '#111';
                    ctx.fillRect(x - keyWidth / 4, 0, keyWidth / 2, blackKeyHeight);
                    ctx.strokeRect(x - keyWidth / 4, 0, keyWidth / 2, blackKeyHeight);
                    
                    // Highlight if active
                    if (activeNotes.has(noteNumber)) {
                        ctx.fillStyle = `rgba(${themeColorRgb}, 0.6)`;
                        ctx.fillRect(x - keyWidth / 4, 0, keyWidth / 2, blackKeyHeight);
                    }
                    
                    // Label
                    const blackNote = noteToName(noteNumber, currentNotation);
                    ctx.font = activeNotes.has(noteNumber) ? 'bold 10px Roboto' : '9px Roboto';
                    ctx.fillStyle = activeNotes.has(noteNumber) ? themeColor : '#eee';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(blackNote, x, blackKeyHeight - 5);
                }
            }
        }
        
        // Playback Functions
        function startPlayback() {
            if (isPlaying || midiNotes.length === 0) return;
            
            isPlaying = true;
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            
            const speed = parseFloat(speedSlider.value);
            const startTime = Date.now();
            const startPlaybackTime = playbackTime;
            
            playbackTimer = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                playbackTime = startPlaybackTime + elapsed * speed;
                
                // Clear previous active notes
                activeNotes.clear();
                
                // Find notes at current time (with tolerance)
                const currentNotes = midiNotes.filter(note => 
                    Math.abs(note.time - playbackTime) < 0.1
                );
                
                currentNotes.forEach(note => {
                    activeNotes.add(note.number);
                    const info = `<span style="color: ${themeColor}">‚ô™</span> Note: ${note.name} (${note.number}) at ${playbackTime.toFixed(2)}s<br>`;
                    midiInfo.innerHTML += info;
                    midiInfo.scrollTop = midiInfo.scrollHeight;
                });
                
                // Update visualizations
                if (currentNotes.length > 0) {
                    drawFretboard();
                    drawPianoRoll();
                }
                
                // Check if playback finished
                if (playbackTime > midiNotes[midiNotes.length - 1].time + 1) {
                    stopPlayback();
                }
            }, 50); // 20fps for smooth playback
        }
        
        function pausePlayback() {
            if (!isPlaying) return;
            
            clearInterval(playbackTimer);
            isPlaying = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
        }
        
        function stopPlayback() {
            clearInterval(playbackTimer);
            isPlaying = false;
            playbackTime = 0;
            activeNotes.clear();
            
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            
            midiInfo.innerHTML = '';
            drawFretboard();
            drawPianoRoll();
        }
        
        // Event Handlers
        uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                // Convert ArrayBuffer to base64 string for midi-parser-js
                const arrayBuffer = e.target.result;
                const bytes = new Uint8Array(arrayBuffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                const base64 = btoa(binary);
                
                midiNotes = parseMidi(base64);
                
                if (midiNotes.length > 0) {
                    statusMessage.textContent = `Loaded: ${file.name} (${midiNotes.length} notes)`;
                    statusMessage.style.color = themeColor;
                    playBtn.disabled = false;
                    speedSlider.disabled = false;
                    sampleSelect.value = '';
                } else {
                    statusMessage.textContent = 'Error: Could not parse MIDI file';
                    statusMessage.style.color = '#ff6b6b';
                }
            };
            reader.readAsArrayBuffer(file);
        });
        
        sampleSelect.addEventListener('change', (e) => {
            if (!e.target.value) return;
            
            midiNotes = generateSampleMidi(e.target.value);
            statusMessage.textContent = `Loaded sample: ${e.target.options[e.target.selectedIndex].text}`;
            statusMessage.style.color = themeColor;
            playBtn.disabled = false;
            speedSlider.disabled = false;
        });
        
        playBtn.addEventListener('click', startPlayback);
        pauseBtn.addEventListener('click', pausePlayback);
        stopBtn.addEventListener('click', stopPlayback);
        
        speedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            speedDisplay.textContent = speed.toFixed(1) + 'x';
            
            if (isPlaying) {
                pausePlayback();
                startPlayback();
            }
        });
        
        notationSelect.addEventListener('change', (e) => {
            currentNotation = e.target.value;
            midiNotes = midiNotes.map(note => ({
                ...note,
                name: noteToName(note.number, currentNotation)
            }));
            drawFretboard();
            drawPianoRoll();
        });
        
        tuningSelect.addEventListener('change', (e) => {
            currentTuning = tunings[e.target.value];
            drawFretboard();
        });
        
        stringOrderSelect.addEventListener('change', (e) => {
            currentStringOrder = e.target.value;
            drawFretboard();
        });
        
        themeColorInput.addEventListener('input', (e) => {
            updateThemeColor(e.target.value);
        });
        
        // Initialize
        drawFretboard();
        drawPianoRoll();
    </script>
</body>
</html>
